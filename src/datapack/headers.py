
# Import config
from src.config import *
from src.utils.io import *
from src.utils.print import *
import json

# Get all mcfunctions paths
mcfunctions = {}
functions_folder = f"{BUILD_DATAPACK}/data/{NAMESPACE}/functions"
for root, _, files in os.walk(functions_folder):
	for file in files:
		if file.endswith(".mcfunction"):
			file_path: str = f"{root}/{file}".replace("\\", "/")
			
			# Get string that is used for calling the function (ex: "function:my_function")
			to_be_called = f"{NAMESPACE}:" + file_path.replace(functions_folder + "/", "").replace(".mcfunction","")
			
			# Add to mcfunctions dictionary
			mcfunctions[to_be_called] = {"path":f"{root}/{file}", "within":[]}
	pass

# For each json file, get the functions that it calls
functions_tags_folder = f"{BUILD_DATAPACK}/data/{NAMESPACE}/tags/functions"
for root, _, files in os.walk(functions_tags_folder):
	for file in files:
		if file.endswith(".json"):
			file_path: str = f"{root}/{file}".replace("\\", "/")

			# Get string that is used for calling the function (ex: "function:my_function")
			to_be_called = f"#{NAMESPACE}:" + f"{root}/{file}".replace(functions_tags_folder + "/", "").replace(".json","")

			# Read the json file and loop its values
			with super_open(f"{root}/{file}", "r") as f:
				data = json.load(f)
				if data.get("values"):
					for value in data["values"]:

						# Get the function that is called, either "function" or {"id": "function", ...}
						calling = value if type(value) == str else value["id"]

						# If the called function is registered, append the name of this file
						if calling in mcfunctions.keys():
							mcfunctions[calling]["within"].append(to_be_called)
	pass

# For each mcfunction file, look at each lines
for file, data in mcfunctions.items():
	with super_open(data["path"], "r") as f:
		for line in f.readlines():

			# If the line call a function,
			if "function " in line:

				# Get the called function
				splitted = line.split("function ")[1].replace("\n","").split(" ")
				calling = splitted[0]

				# Get additional text like macros, ex: function iyc:function {id:"51"}
				more = ""
				if len(splitted) > 0:
					more = " " + " ".join(splitted[1:]) # Add Macros or schedule time
				
				# If the called function is registered, append the name of this file as well as the additional text
				if calling in mcfunctions.keys():
					mcfunctions[calling]["within"].append(file + more)
	pass

# For each mcfunction file, add the header
for file, data in mcfunctions.items():

	# Get file content
	with super_open(data["path"], "r") as f:
		content = f.read()
	
	# Prepare header
	header: str = f"""
#> {file} (Autogenerated)
#
"""

	# Get all the calling function and join them with new lines
	withins = "\n#\t\t\t".join(w.strip() for w in data["within"])
	if data["within"]:
		header += f"# @within\t{withins}\n#\n"

	# Re-write the file
	with super_open(data["path"], "w") as f:
		f.write(header + content)
	pass
info("Headers added to all mcfunction files")

